from fastapi import HTTPException, Depends
from datetime import datetime
import csv
import pickle
import time

from rq import Queue
from redis import Redis
from app.config import config

from app.repositories.prediction_repo import (
    PredictionRepository,
    get_prediction_repository
    )
from app.repositories.user_repo import UserRepository, get_user_repository
from app.repositories.model_repo import ModelRepository, get_model_repository
from app.schemas.prediction import PredictionResponse


# Подключение к серверу Redis
redis_conn = Redis(host=config.redis_host, port=config.redis_port)
queue = Queue(connection=redis_conn, default_timeout=900)


# Сервисный слой для работы с предиктами
class PredictionService:
    def __init__(
        self,
        user_repo: UserRepository,
        model_repo: ModelRepository,
        db: PredictionRepository,
    ) -> None:
        self.user_repo = user_repo
        self.model_repo = model_repo
        self.db = db

    async def create_prediction(
        self, user_id: int, name_model: str, file: bytes
    ) -> PredictionResponse:
        db_user = self.user_repo.get_user_by_id(user_id)
        db_model = self.model_repo.get_model_by_name(name=name_model)
        db_prediction = None

        try:
            # Проверка баланса
            if db_user.credits < db_model.cost_in_credits:
                # Автопополнение баланса пользователя
                print("Вы классный! Мы дарим вам еще 100 кредитов!")
                add_credits = db_user.credits + 100
                self.user_repo.update_user_credits(user_id, add_credits)

            # Списание кредитов
            new_balance = db_user.credits - db_model.cost_in_credits
            self.user_repo.update_user_credits(user_id, new_balance)

            # Добавление задачи в очередь для предсказания
            job = queue.enqueue("app.core.model_inference.predict_malware",
                                args=(file, name_model)
                                )
            print(job.get_status)

            while job.get_status(refresh=True) != "finished":
                time.sleep(1)

            if job.result:
                print("Прогноз выполнен успешно!")

                db_prediction = await self.db.create_prediction(
                    user_id, datetime.now(), name_model, job.result
                )
        except Exception as e:
            print(e)
            raise HTTPException(status_code=400,
                                detail="Прогноз не удался, "
                                "списание кредитов отменено!"
                                )
        return {"prediction_id": db_prediction.id}

    async def get_file_path_by_pred_id(self, prediction_id: int):

        prediction = self.db.get_predictions_by_id(id=prediction_id)
        csv_file_path = f"app/predictions_folder/{prediction_id}.csv"
        print(prediction)
        with open(csv_file_path, "w", newline="") as csvfile:
            csv_writer = csv.writer(csvfile, delimiter=",")
            csv_writer.writerow(["id",
                                 "user_id",
                                 "datetime",
                                 "name_model",
                                 "results"])

            if prediction.results:
                # Десериализация в список строк
                results_list = pickle.loads(prediction.results)

                for result in results_list:
                    row_data = [prediction.id,
                                prediction.user_id,
                                prediction.datetime,
                                prediction.name_model,
                                result]

                    csv_writer.writerow(row_data)

        return {"file_path": csv_file_path}


# Внедрение зависимости от репозитория в экземпляр PredictionService
def get_prediction_service(
    prediction_repo: PredictionRepository = Depends(get_prediction_repository),
    user_repo: UserRepository = Depends(get_user_repository),
    model_repo: ModelRepository = Depends(get_model_repository),
) -> PredictionService:
    prediction_service = PredictionService(user_repo,
                                           model_repo,
                                           prediction_repo)
    return prediction_service
